"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_aircraft_tracking_LeafletMap_tsx",{

/***/ "./pages/api/opensky.ts":
/*!******************************!*\
  !*** ./pages/api/opensky.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenSkyService: () => (/* binding */ OpenSkyService),\n/* harmony export */   openSkyService: () => (/* binding */ openSkyService)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"./node_modules/node-cache/index.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nconst RETRY_ATTEMPTS = 3;\nconst RETRY_DELAY = 2000;\nconst WS_RECONNECT_DELAY = 5000;\nconst API_ENDPOINTS = [\n    'https://opensky-network.org/api',\n    'https://api.opensky-network.org'\n];\n// OpenSky API state vector array indices\nconst ICAO24_INDEX = 0;\nconst LONGITUDE_INDEX = 5;\nconst LATITUDE_INDEX = 6;\nconst ALTITUDE_INDEX = 13; // baro_altitude\nconst VELOCITY_INDEX = 9; // velocity\nconst HEADING_INDEX = 10; // true_track\nconst ON_GROUND_INDEX = 8;\nconst LAST_CONTACT_INDEX = 4;\nclass OpenSkyService {\n    async retryOperation(operation) {\n        let lastError = null;\n        for(let attempt = 1; attempt <= RETRY_ATTEMPTS; attempt++){\n            try {\n                return await operation();\n            } catch (error) {\n                lastError = error;\n                console.error(\"Attempt \".concat(attempt, \" failed:\"), error);\n                if (attempt < RETRY_ATTEMPTS) {\n                    this.currentEndpointIndex = (this.currentEndpointIndex + 1) % API_ENDPOINTS.length;\n                    await new Promise((resolve)=>setTimeout(resolve, RETRY_DELAY * attempt));\n                }\n            }\n        }\n        throw lastError || new Error('Operation failed after retries');\n    }\n    getCurrentEndpoint() {\n        return API_ENDPOINTS[this.currentEndpointIndex];\n    }\n    initWebSocket() {\n        if (this.ws || !this.isWebSocketEnabled) return;\n        try {\n            const encodedUsername = encodeURIComponent(this.username);\n            const encodedPassword = encodeURIComponent(this.password);\n            const wsUrl = \"wss://opensky-network.org/api/websocket/auth?username=\".concat(encodedUsername, \"&password=\").concat(encodedPassword);\n            console.log('Initializing WebSocket connection...');\n            this.ws = new (ws__WEBPACK_IMPORTED_MODULE_0___default())(wsUrl);\n            this.ws.on('open', ()=>{\n                var _this_ws;\n                console.log('WebSocket connection established');\n                this.wsReconnectAttempts = 0;\n                if (this.reconnectTimeout) {\n                    clearTimeout(this.reconnectTimeout);\n                    this.reconnectTimeout = null;\n                }\n                if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === (ws__WEBPACK_IMPORTED_MODULE_0___default().OPEN)) {\n                    this.subscribeToUpdates();\n                }\n            });\n            this.ws.on('message', this.handleWebSocketMessage.bind(this));\n            this.ws.on('close', ()=>{\n                console.log('WebSocket connection closed');\n                this.handleWebSocketClose();\n            });\n            this.ws.on('error', (error)=>{\n                console.error('WebSocket error:', error);\n                this.handleWebSocketError(error);\n            });\n        } catch (error) {\n            console.error('Failed to initialize WebSocket:', error);\n            this.handleWebSocketError(error);\n        }\n    }\n    handleWebSocketMessage(data) {\n        try {\n            const positions = JSON.parse(data.toString());\n            this.broadcastPositions(positions);\n            this.updateCache(positions);\n        } catch (error) {\n            console.error('Error processing WebSocket message:', error);\n        }\n    }\n    handleWebSocketClose() {\n        this.ws = null;\n        if (this.isWebSocketEnabled) {\n            this.scheduleReconnect();\n        }\n    }\n    handleWebSocketError(error) {\n        var _this_ws;\n        console.error('WebSocket error:', error);\n        (_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.close();\n        this.ws = null;\n        this.wsReconnectAttempts++;\n        if (this.wsReconnectAttempts >= this.maxWsReconnectAttempts) {\n            console.log('Max WebSocket reconnection attempts reached, disabling WebSocket');\n            this.isWebSocketEnabled = false;\n        } else {\n            this.scheduleReconnect();\n        }\n    }\n    subscribeToUpdates() {\n        var _this_ws;\n        if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === (ws__WEBPACK_IMPORTED_MODULE_0___default().OPEN)) {\n            console.log('Subscribing to aircraft updates');\n            this.ws.send(JSON.stringify({\n                type: 'subscribe',\n                filters: {\n                    states: true\n                }\n            }));\n        }\n    }\n    scheduleReconnect() {\n        if (!this.reconnectTimeout && this.isWebSocketEnabled) {\n            this.reconnectTimeout = setTimeout(()=>{\n                console.log('Attempting to reconnect WebSocket...');\n                this.initWebSocket();\n            }, WS_RECONNECT_DELAY);\n        }\n    }\n    broadcastPositions(positions) {\n        if (!this.isWebSocketEnabled) return;\n        const message = JSON.stringify(positions);\n        this.wsClients.forEach((client)=>{\n            if (client.readyState === (ws__WEBPACK_IMPORTED_MODULE_0___default().OPEN)) {\n                try {\n                    client.send(message);\n                } catch (error) {\n                    console.error('Error broadcasting to client:', error);\n                }\n            }\n        });\n    }\n    updateCache(positions) {\n        try {\n            const cachedData = this.cache.get('positions') || {};\n            const updatedData = {\n                ...cachedData,\n                ...positions\n            };\n            this.cache.set('positions', updatedData);\n        } catch (error) {\n            console.error('Error updating cache:', error);\n        }\n    }\n    transformStateToPosition(state) {\n        if (!state || !state[ICAO24_INDEX]) return null;\n        const icao24 = state[ICAO24_INDEX];\n        const longitude = parseFloat(state[LONGITUDE_INDEX]);\n        const latitude = parseFloat(state[LATITUDE_INDEX]);\n        const altitude = parseFloat(state[ALTITUDE_INDEX]);\n        const velocity = parseFloat(state[VELOCITY_INDEX]);\n        const heading = parseFloat(state[HEADING_INDEX]);\n        const on_ground = Boolean(state[ON_GROUND_INDEX]);\n        const last_contact = parseInt(state[LAST_CONTACT_INDEX]);\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return null;\n        }\n        return {\n            icao24,\n            longitude: isNaN(longitude) ? undefined : longitude,\n            latitude: isNaN(latitude) ? undefined : latitude,\n            altitude: isNaN(altitude) ? undefined : altitude,\n            velocity: isNaN(velocity) ? undefined : velocity,\n            heading: isNaN(heading) ? undefined : heading,\n            on_ground,\n            last_contact: isNaN(last_contact) ? undefined : last_contact\n        };\n    }\n    async getPositions(icao24List) {\n        if (!icao24List.length) {\n            return {};\n        }\n        return this.retryOperation(async ()=>{\n            try {\n                console.log('Fetching positions for:', icao24List.length, 'aircraft');\n                const config = {};\n                if (this.username && this.password) {\n                    config.auth = {\n                        username: this.username,\n                        password: this.password\n                    };\n                }\n                const chunkSize = 100;\n                const positions = {};\n                for(let i = 0; i < icao24List.length; i += chunkSize){\n                    const chunk = icao24List.slice(i, i + chunkSize);\n                    const formattedIcaos = chunk.map((icao)=>icao.toLowerCase()).join(',');\n                    const endpoint = this.getCurrentEndpoint();\n                    console.log(\"Fetching from \".concat(endpoint, \" (chunk \").concat(i / chunkSize + 1, \"/\").concat(Math.ceil(icao24List.length / chunkSize), \")\"));\n                    try {\n                        var _response_data;\n                        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(endpoint, \"/states/all?icao24=\").concat(formattedIcaos), config);\n                        if ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.states) {\n                            response.data.states.forEach((state)=>{\n                                const position = this.transformStateToPosition(state);\n                                if (position) {\n                                    positions[position.icao24] = position;\n                                }\n                            });\n                        }\n                        // Briefly check cache for any additional positions\n                        const cachedData = this.cache.get('positions') || {};\n                        chunk.forEach((icao24)=>{\n                            if (!positions[icao24] && cachedData[icao24]) {\n                                positions[icao24] = cachedData[icao24];\n                            }\n                        });\n                    } catch (error) {\n                        console.error(\"Error fetching chunk \".concat(i / chunkSize + 1, \":\"), error);\n                    }\n                    // Add a small delay between chunks\n                    if (i + chunkSize < icao24List.length) {\n                        await new Promise((resolve)=>setTimeout(resolve, 500));\n                    }\n                }\n                console.log('Retrieved positions for:', Object.keys(positions).length, 'aircraft');\n                return positions;\n            } catch (error) {\n                console.error('Error fetching aircraft positions:', error);\n                return {};\n            }\n        });\n    }\n    addClient(ws) {\n        if (!this.isWebSocketEnabled) return;\n        this.wsClients.add(ws);\n        ws.on('close', ()=>{\n            this.wsClients.delete(ws);\n        });\n    }\n    removeClient(ws) {\n        if (!this.isWebSocketEnabled) return;\n        this.wsClients.delete(ws);\n    }\n    constructor(){\n        this.ws = null;\n        this.wsClients = new Set();\n        this.reconnectTimeout = null;\n        this.currentEndpointIndex = 0;\n        this.wsReconnectAttempts = 0;\n        this.maxWsReconnectAttempts = 5;\n        this.cache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n            stdTTL: 15\n        });\n        this.username = process.env.NEXT_PUBLIC_OPENSKY_USERNAME || '';\n        this.password = process.env.NEXT_PUBLIC_OPENSKY_PASSWORD || '';\n        const hasCredentials = Boolean(this.username && this.password);\n        console.log('OpenSky credentials available:', hasCredentials);\n        this.isWebSocketEnabled = hasCredentials;\n        if (this.isWebSocketEnabled) {\n            console.log('Attempting WebSocket connection...');\n            this.initWebSocket();\n        } else {\n            console.log('Using REST API only mode');\n        }\n    }\n}\nconst openSkyService = new OpenSkyService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEMsSUFBSSxDQUFDakYsUUFBUSxHQUFHa0YsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyw0QkFBNEIsSUFBSTtRQUM1RCxJQUFJLENBQUNsRixRQUFRLEdBQUdnRixPQUFPQSxDQUFDQyxHQUFHLENBQUNFLDRCQUE0QixJQUFJO1FBRTVELE1BQU1DLGlCQUFpQnBDLFFBQVEsSUFBSSxDQUFDbEQsUUFBUSxJQUFJLElBQUksQ0FBQ0UsUUFBUTtRQUM3RGYsUUFBUWlCLEdBQUcsQ0FBQyxrQ0FBa0NrRjtRQUM5QyxJQUFJLENBQUN6RixrQkFBa0IsR0FBR3lGO1FBRTFCLElBQUksSUFBSSxDQUFDekYsa0JBQWtCLEVBQUU7WUFDM0JWLFFBQVFpQixHQUFHLENBQUM7WUFDWixJQUFJLENBQUNULGFBQWE7UUFDcEIsT0FBTztZQUNMUixRQUFRaUIsR0FBRyxDQUFDO1FBQ2Q7SUFDRjtBQThQRjtBQUVPLE1BQU1tRixpQkFBaUIsSUFBSTFHLGlCQUFpQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzYXRob1xcRG9jdW1lbnRzXFxQcm9qZWN0c1xcQWlyY3JhZnQtVHJhY2tpbmdcXHBhZ2VzXFxhcGlcXG9wZW5za3kudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuaW1wb3J0IFdlYlNvY2tldCBmcm9tICd3cyc7XHJcbmltcG9ydCBOb2RlQ2FjaGUgZnJvbSAnbm9kZS1jYWNoZSc7XHJcblxyXG5pbnRlcmZhY2UgUG9zaXRpb25EYXRhIHtcclxuICBbaWNhbzI0OiBzdHJpbmddOiB7XHJcbiAgICBpY2FvMjQ6IHN0cmluZztcclxuICAgIGxhdGl0dWRlOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBsb25naXR1ZGU6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIHZlbG9jaXR5OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBoZWFkaW5nOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBhbHRpdHVkZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgb25fZ3JvdW5kOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgbGFzdF9jb250YWN0OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBSRVRSWV9BVFRFTVBUUyA9IDM7XHJcbmNvbnN0IFJFVFJZX0RFTEFZID0gMjAwMDtcclxuY29uc3QgV1NfUkVDT05ORUNUX0RFTEFZID0gNTAwMDtcclxuY29uc3QgQVBJX0VORFBPSU5UUyA9IFtcclxuICAnaHR0cHM6Ly9vcGVuc2t5LW5ldHdvcmsub3JnL2FwaScsXHJcbiAgJ2h0dHBzOi8vYXBpLm9wZW5za3ktbmV0d29yay5vcmcnXHJcbl07XHJcblxyXG4vLyBPcGVuU2t5IEFQSSBzdGF0ZSB2ZWN0b3IgYXJyYXkgaW5kaWNlc1xyXG5jb25zdCBJQ0FPMjRfSU5ERVggPSAwO1xyXG5jb25zdCBMT05HSVRVREVfSU5ERVggPSA1O1xyXG5jb25zdCBMQVRJVFVERV9JTkRFWCA9IDY7XHJcbmNvbnN0IEFMVElUVURFX0lOREVYID0gMTM7ICAvLyBiYXJvX2FsdGl0dWRlXHJcbmNvbnN0IFZFTE9DSVRZX0lOREVYID0gOTsgICAvLyB2ZWxvY2l0eVxyXG5jb25zdCBIRUFESU5HX0lOREVYID0gMTA7ICAgLy8gdHJ1ZV90cmFja1xyXG5jb25zdCBPTl9HUk9VTkRfSU5ERVggPSA4O1xyXG5jb25zdCBMQVNUX0NPTlRBQ1RfSU5ERVggPSA0O1xyXG5cclxuZXhwb3J0IGNsYXNzIE9wZW5Ta3lTZXJ2aWNlIHtcclxuICBwcml2YXRlIGNhY2hlOiBOb2RlQ2FjaGU7XHJcbiAgcHJpdmF0ZSB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSB3c0NsaWVudHM6IFNldDxXZWJTb2NrZXQ+ID0gbmV3IFNldCgpO1xyXG4gIHByaXZhdGUgcmVjb25uZWN0VGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlYWRvbmx5IHVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBwYXNzd29yZDogc3RyaW5nO1xyXG4gIHByaXZhdGUgaXNXZWJTb2NrZXRFbmFibGVkOiBib29sZWFuO1xyXG4gIHByaXZhdGUgY3VycmVudEVuZHBvaW50SW5kZXg6IG51bWJlciA9IDA7XHJcbiAgcHJpdmF0ZSB3c1JlY29ubmVjdEF0dGVtcHRzOiBudW1iZXIgPSAwO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4V3NSZWNvbm5lY3RBdHRlbXB0czogbnVtYmVyID0gNTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNhY2hlID0gbmV3IE5vZGVDYWNoZSh7IHN0ZFRUTDogMTUgfSk7XHJcbiAgICB0aGlzLnVzZXJuYW1lID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTlNLWV9VU0VSTkFNRSB8fCAnJztcclxuICAgIHRoaXMucGFzc3dvcmQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOU0tZX1BBU1NXT1JEIHx8ICcnO1xyXG4gICAgXHJcbiAgICBjb25zdCBoYXNDcmVkZW50aWFscyA9IEJvb2xlYW4odGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKTtcclxuICAgIGNvbnNvbGUubG9nKCdPcGVuU2t5IGNyZWRlbnRpYWxzIGF2YWlsYWJsZTonLCBoYXNDcmVkZW50aWFscyk7XHJcbiAgICB0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCA9IGhhc0NyZWRlbnRpYWxzO1xyXG5cclxuICAgIGlmICh0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyBXZWJTb2NrZXQgY29ubmVjdGlvbi4uLicpO1xyXG4gICAgICB0aGlzLmluaXRXZWJTb2NrZXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBSRVNUIEFQSSBvbmx5IG1vZGUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmV0cnlPcGVyYXRpb248VD4ob3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XHJcbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IFJFVFJZX0FUVEVNUFRTOyBhdHRlbXB0KyspIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgb3BlcmF0aW9uKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgQXR0ZW1wdCAke2F0dGVtcHR9IGZhaWxlZDpgLCBlcnJvcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGF0dGVtcHQgPCBSRVRSWV9BVFRFTVBUUykge1xyXG4gICAgICAgICAgdGhpcy5jdXJyZW50RW5kcG9pbnRJbmRleCA9ICh0aGlzLmN1cnJlbnRFbmRwb2ludEluZGV4ICsgMSkgJSBBUElfRU5EUE9JTlRTLmxlbmd0aDtcclxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBSRVRSWV9ERUxBWSAqIGF0dGVtcHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKCdPcGVyYXRpb24gZmFpbGVkIGFmdGVyIHJldHJpZXMnKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0Q3VycmVudEVuZHBvaW50KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gQVBJX0VORFBPSU5UU1t0aGlzLmN1cnJlbnRFbmRwb2ludEluZGV4XTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5pdFdlYlNvY2tldCgpIHtcclxuICAgIGlmICh0aGlzLndzIHx8ICF0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCkgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGVuY29kZWRVc2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnVzZXJuYW1lKTtcclxuICAgICAgY29uc3QgZW5jb2RlZFBhc3N3b3JkID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucGFzc3dvcmQpO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgd3NVcmwgPSBgd3NzOi8vb3BlbnNreS1uZXR3b3JrLm9yZy9hcGkvd2Vic29ja2V0L2F1dGg/dXNlcm5hbWU9JHtlbmNvZGVkVXNlcm5hbWV9JnBhc3N3b3JkPSR7ZW5jb2RlZFBhc3N3b3JkfWA7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24uLi4nKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHdzVXJsKTtcclxuXHJcbiAgICAgIHRoaXMud3Mub24oJ29wZW4nLCAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVzdGFibGlzaGVkJyk7XHJcbiAgICAgICAgdGhpcy53c1JlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcclxuICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG9VcGRhdGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMud3Mub24oJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZVdlYlNvY2tldE1lc3NhZ2UuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICB0aGlzLndzLm9uKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkJyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVXZWJTb2NrZXRDbG9zZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMud3Mub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB0aGlzLmhhbmRsZVdlYlNvY2tldEVycm9yKGVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgV2ViU29ja2V0OicsIGVycm9yKTtcclxuICAgICAgdGhpcy5oYW5kbGVXZWJTb2NrZXRFcnJvcihlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoZGF0YTogV2ViU29ja2V0LlJhd0RhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2UoZGF0YS50b1N0cmluZygpKTtcclxuICAgICAgdGhpcy5icm9hZGNhc3RQb3NpdGlvbnMocG9zaXRpb25zKTtcclxuICAgICAgdGhpcy51cGRhdGVDYWNoZShwb3NpdGlvbnMpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhbmRsZVdlYlNvY2tldENsb3NlKCkge1xyXG4gICAgdGhpcy53cyA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5pc1dlYlNvY2tldEVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVXZWJTb2NrZXRFcnJvcihlcnJvcjogdW5rbm93bikge1xyXG4gICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcclxuICAgIHRoaXMud3M/LmNsb3NlKCk7XHJcbiAgICB0aGlzLndzID0gbnVsbDtcclxuICAgIFxyXG4gICAgdGhpcy53c1JlY29ubmVjdEF0dGVtcHRzKys7XHJcbiAgICBpZiAodGhpcy53c1JlY29ubmVjdEF0dGVtcHRzID49IHRoaXMubWF4V3NSZWNvbm5lY3RBdHRlbXB0cykge1xyXG4gICAgICBjb25zb2xlLmxvZygnTWF4IFdlYlNvY2tldCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCwgZGlzYWJsaW5nIFdlYlNvY2tldCcpO1xyXG4gICAgICB0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb1VwZGF0ZXMoKSB7XHJcbiAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgY29uc29sZS5sb2coJ1N1YnNjcmliaW5nIHRvIGFpcmNyYWZ0IHVwZGF0ZXMnKTtcclxuICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICB0eXBlOiAnc3Vic2NyaWJlJyxcclxuICAgICAgICBmaWx0ZXJzOiB7IHN0YXRlczogdHJ1ZSB9XHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2NoZWR1bGVSZWNvbm5lY3QoKSB7XHJcbiAgICBpZiAoIXRoaXMucmVjb25uZWN0VGltZW91dCAmJiB0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCkge1xyXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byByZWNvbm5lY3QgV2ViU29ja2V0Li4uJyk7XHJcbiAgICAgICAgdGhpcy5pbml0V2ViU29ja2V0KCk7XHJcbiAgICAgIH0sIFdTX1JFQ09OTkVDVF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGJyb2FkY2FzdFBvc2l0aW9ucyhwb3NpdGlvbnM6IFBvc2l0aW9uRGF0YSkge1xyXG4gICAgaWYgKCF0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkocG9zaXRpb25zKTtcclxuICAgIHRoaXMud3NDbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHtcclxuICAgICAgaWYgKGNsaWVudC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjbGllbnQuc2VuZChtZXNzYWdlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYnJvYWRjYXN0aW5nIHRvIGNsaWVudDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlQ2FjaGUocG9zaXRpb25zOiBQb3NpdGlvbkRhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlLmdldDxQb3NpdGlvbkRhdGE+KCdwb3NpdGlvbnMnKSB8fCB7fTtcclxuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7IC4uLmNhY2hlZERhdGEsIC4uLnBvc2l0aW9ucyB9O1xyXG4gICAgICB0aGlzLmNhY2hlLnNldCgncG9zaXRpb25zJywgdXBkYXRlZERhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY2FjaGU6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB0cmFuc2Zvcm1TdGF0ZVRvUG9zaXRpb24oc3RhdGU6IGFueVtdKTogUG9zaXRpb25EYXRhW3N0cmluZ10gfCBudWxsIHtcclxuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlW0lDQU8yNF9JTkRFWF0pIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IGljYW8yNCA9IHN0YXRlW0lDQU8yNF9JTkRFWF07XHJcbiAgICBjb25zdCBsb25naXR1ZGUgPSBwYXJzZUZsb2F0KHN0YXRlW0xPTkdJVFVERV9JTkRFWF0pO1xyXG4gICAgY29uc3QgbGF0aXR1ZGUgPSBwYXJzZUZsb2F0KHN0YXRlW0xBVElUVURFX0lOREVYXSk7XHJcbiAgICBjb25zdCBhbHRpdHVkZSA9IHBhcnNlRmxvYXQoc3RhdGVbQUxUSVRVREVfSU5ERVhdKTtcclxuICAgIGNvbnN0IHZlbG9jaXR5ID0gcGFyc2VGbG9hdChzdGF0ZVtWRUxPQ0lUWV9JTkRFWF0pO1xyXG4gICAgY29uc3QgaGVhZGluZyA9IHBhcnNlRmxvYXQoc3RhdGVbSEVBRElOR19JTkRFWF0pO1xyXG4gICAgY29uc3Qgb25fZ3JvdW5kID0gQm9vbGVhbihzdGF0ZVtPTl9HUk9VTkRfSU5ERVhdKTtcclxuICAgIGNvbnN0IGxhc3RfY29udGFjdCA9IHBhcnNlSW50KHN0YXRlW0xBU1RfQ09OVEFDVF9JTkRFWF0pO1xyXG5cclxuICAgIGlmIChpc05hTihsYXRpdHVkZSkgfHwgaXNOYU4obG9uZ2l0dWRlKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpY2FvMjQsXHJcbiAgICAgIGxvbmdpdHVkZTogaXNOYU4obG9uZ2l0dWRlKSA/IHVuZGVmaW5lZCA6IGxvbmdpdHVkZSxcclxuICAgICAgbGF0aXR1ZGU6IGlzTmFOKGxhdGl0dWRlKSA/IHVuZGVmaW5lZCA6IGxhdGl0dWRlLFxyXG4gICAgICBhbHRpdHVkZTogaXNOYU4oYWx0aXR1ZGUpID8gdW5kZWZpbmVkIDogYWx0aXR1ZGUsXHJcbiAgICAgIHZlbG9jaXR5OiBpc05hTih2ZWxvY2l0eSkgPyB1bmRlZmluZWQgOiB2ZWxvY2l0eSxcclxuICAgICAgaGVhZGluZzogaXNOYU4oaGVhZGluZykgPyB1bmRlZmluZWQgOiBoZWFkaW5nLFxyXG4gICAgICBvbl9ncm91bmQsXHJcbiAgICAgIGxhc3RfY29udGFjdDogaXNOYU4obGFzdF9jb250YWN0KSA/IHVuZGVmaW5lZCA6IGxhc3RfY29udGFjdFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRQb3NpdGlvbnMoaWNhbzI0TGlzdDogc3RyaW5nW10pOiBQcm9taXNlPFBvc2l0aW9uRGF0YT4ge1xyXG4gICAgaWYgKCFpY2FvMjRMaXN0Lmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmV0cnlPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwb3NpdGlvbnMgZm9yOicsIGljYW8yNExpc3QubGVuZ3RoLCAnYWlyY3JhZnQnKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBjb25maWc6IGFueSA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcclxuICAgICAgICAgIGNvbmZpZy5hdXRoID0ge1xyXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMucGFzc3dvcmRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjaHVua1NpemUgPSAxMDA7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25zOiBQb3NpdGlvbkRhdGEgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpY2FvMjRMaXN0Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcclxuICAgICAgICAgIGNvbnN0IGNodW5rID0gaWNhbzI0TGlzdC5zbGljZShpLCBpICsgY2h1bmtTaXplKTtcclxuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEljYW9zID0gY2h1bmsubWFwKGljYW8gPT4gaWNhby50b0xvd2VyQ2FzZSgpKS5qb2luKCcsJyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5nZXRDdXJyZW50RW5kcG9pbnQoKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBmcm9tICR7ZW5kcG9pbnR9IChjaHVuayAke2kvY2h1bmtTaXplICsgMX0vJHtNYXRoLmNlaWwoaWNhbzI0TGlzdC5sZW5ndGgvY2h1bmtTaXplKX0pYCk7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXHJcbiAgICAgICAgICAgICAgYCR7ZW5kcG9pbnR9L3N0YXRlcy9hbGw/aWNhbzI0PSR7Zm9ybWF0dGVkSWNhb3N9YCxcclxuICAgICAgICAgICAgICBjb25maWdcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhPy5zdGF0ZXMpIHtcclxuICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLnN0YXRlcy5mb3JFYWNoKChzdGF0ZTogYW55W10pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy50cmFuc2Zvcm1TdGF0ZVRvUG9zaXRpb24oc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbi5pY2FvMjRdID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEJyaWVmbHkgY2hlY2sgY2FjaGUgZm9yIGFueSBhZGRpdGlvbmFsIHBvc2l0aW9uc1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5jYWNoZS5nZXQ8UG9zaXRpb25EYXRhPigncG9zaXRpb25zJykgfHwge307XHJcbiAgICAgICAgICAgIGNodW5rLmZvckVhY2goaWNhbzI0ID0+IHtcclxuICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uc1tpY2FvMjRdICYmIGNhY2hlZERhdGFbaWNhbzI0XSkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2ljYW8yNF0gPSBjYWNoZWREYXRhW2ljYW8yNF07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjaHVuayAke2kvY2h1bmtTaXplICsgMX06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IGJldHdlZW4gY2h1bmtzXHJcbiAgICAgICAgICBpZiAoaSArIGNodW5rU2l6ZSA8IGljYW8yNExpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXRyaWV2ZWQgcG9zaXRpb25zIGZvcjonLCBPYmplY3Qua2V5cyhwb3NpdGlvbnMpLmxlbmd0aCwgJ2FpcmNyYWZ0Jyk7XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhaXJjcmFmdCBwb3NpdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYWRkQ2xpZW50KHdzOiBXZWJTb2NrZXQpIHtcclxuICAgIGlmICghdGhpcy5pc1dlYlNvY2tldEVuYWJsZWQpIHJldHVybjtcclxuICAgIHRoaXMud3NDbGllbnRzLmFkZCh3cyk7XHJcbiAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMud3NDbGllbnRzLmRlbGV0ZSh3cyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW1vdmVDbGllbnQod3M6IFdlYlNvY2tldCkge1xyXG4gICAgaWYgKCF0aGlzLmlzV2ViU29ja2V0RW5hYmxlZCkgcmV0dXJuO1xyXG4gICAgdGhpcy53c0NsaWVudHMuZGVsZXRlKHdzKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBvcGVuU2t5U2VydmljZSA9IG5ldyBPcGVuU2t5U2VydmljZSgpOyJdLCJuYW1lcyI6WyJheGlvcyIsIldlYlNvY2tldCIsIk5vZGVDYWNoZSIsIlJFVFJZX0FUVEVNUFRTIiwiUkVUUllfREVMQVkiLCJXU19SRUNPTk5FQ1RfREVMQVkiLCJBUElfRU5EUE9JTlRTIiwiSUNBTzI0X0lOREVYIiwiTE9OR0lUVURFX0lOREVYIiwiTEFUSVRVREVfSU5ERVgiLCJBTFRJVFVERV9JTkRFWCIsIlZFTE9DSVRZX0lOREVYIiwiSEVBRElOR19JTkRFWCIsIk9OX0dST1VORF9JTkRFWCIsIkxBU1RfQ09OVEFDVF9JTkRFWCIsIk9wZW5Ta3lTZXJ2aWNlIiwicmV0cnlPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJsYXN0RXJyb3IiLCJhdHRlbXB0IiwiZXJyb3IiLCJjb25zb2xlIiwiY3VycmVudEVuZHBvaW50SW5kZXgiLCJsZW5ndGgiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJFcnJvciIsImdldEN1cnJlbnRFbmRwb2ludCIsImluaXRXZWJTb2NrZXQiLCJ3cyIsImlzV2ViU29ja2V0RW5hYmxlZCIsImVuY29kZWRVc2VybmFtZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInVzZXJuYW1lIiwiZW5jb2RlZFBhc3N3b3JkIiwicGFzc3dvcmQiLCJ3c1VybCIsImxvZyIsIm9uIiwid3NSZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInN1YnNjcmliZVRvVXBkYXRlcyIsImhhbmRsZVdlYlNvY2tldE1lc3NhZ2UiLCJiaW5kIiwiaGFuZGxlV2ViU29ja2V0Q2xvc2UiLCJoYW5kbGVXZWJTb2NrZXRFcnJvciIsImRhdGEiLCJwb3NpdGlvbnMiLCJKU09OIiwicGFyc2UiLCJ0b1N0cmluZyIsImJyb2FkY2FzdFBvc2l0aW9ucyIsInVwZGF0ZUNhY2hlIiwic2NoZWR1bGVSZWNvbm5lY3QiLCJjbG9zZSIsIm1heFdzUmVjb25uZWN0QXR0ZW1wdHMiLCJzZW5kIiwic3RyaW5naWZ5IiwidHlwZSIsImZpbHRlcnMiLCJzdGF0ZXMiLCJtZXNzYWdlIiwid3NDbGllbnRzIiwiZm9yRWFjaCIsImNsaWVudCIsImNhY2hlZERhdGEiLCJjYWNoZSIsImdldCIsInVwZGF0ZWREYXRhIiwic2V0IiwidHJhbnNmb3JtU3RhdGVUb1Bvc2l0aW9uIiwic3RhdGUiLCJpY2FvMjQiLCJsb25naXR1ZGUiLCJwYXJzZUZsb2F0IiwibGF0aXR1ZGUiLCJhbHRpdHVkZSIsInZlbG9jaXR5IiwiaGVhZGluZyIsIm9uX2dyb3VuZCIsIkJvb2xlYW4iLCJsYXN0X2NvbnRhY3QiLCJwYXJzZUludCIsImlzTmFOIiwidW5kZWZpbmVkIiwiZ2V0UG9zaXRpb25zIiwiaWNhbzI0TGlzdCIsImNvbmZpZyIsImF1dGgiLCJjaHVua1NpemUiLCJpIiwiY2h1bmsiLCJzbGljZSIsImZvcm1hdHRlZEljYW9zIiwibWFwIiwiaWNhbyIsInRvTG93ZXJDYXNlIiwiam9pbiIsImVuZHBvaW50IiwiTWF0aCIsImNlaWwiLCJyZXNwb25zZSIsInBvc2l0aW9uIiwiT2JqZWN0Iiwia2V5cyIsImFkZENsaWVudCIsImFkZCIsImRlbGV0ZSIsInJlbW92ZUNsaWVudCIsImNvbnN0cnVjdG9yIiwiU2V0Iiwic3RkVFRMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX09QRU5TS1lfVVNFUk5BTUUiLCJORVhUX1BVQkxJQ19PUEVOU0tZX1BBU1NXT1JEIiwiaGFzQ3JlZGVudGlhbHMiLCJvcGVuU2t5U2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/api/opensky.ts\n"));

/***/ })

});